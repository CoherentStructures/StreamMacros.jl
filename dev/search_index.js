var documenterSearchIndex = {"docs":
[{"location":"#StreamMacros.jl-1","page":"Home","title":"StreamMacros.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [StreamMacros]","category":"page"},{"location":"#StreamMacros.@define_stream-Tuple{Symbol,Expr}","page":"Home","title":"StreamMacros.@define_stream","text":"@define_stream(name::Symbol, code::Expr)\n\nDefine a scalar stream function on R^2. The defining code can be a series of definitions in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe symbol name is not brought into the namespace. To access the resulting vector field and variational equation  use @velo_from_stream name and @var_velo_from_stream name\n\nThis is a convenience macro for the case where you want to use @velo_from_stream and @var_velo_from_stream without typing the code twice. If you only use one, you might as well use @velo_from_stream name code or @var_velo_from_stream directly.\n\n\n\n\n\n","category":"macro"},{"location":"#StreamMacros.@var_velo_from_stream-Tuple{Symbol,Expr}","page":"Home","title":"StreamMacros.@var_velo_from_stream","text":"@var_velo_from_stream(name::Symbol, [code::Expr])\n\nGet the (state and tangent space) velocity field corresponding to a stream function on R^2. The defining code can be a series of definitions (in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe macro returns an anonymous function with signature (U,p,t) that returns an SMatrix{2,3}: in the first column, one has the usual velocity, in the second to third column, one has the linearized velocity, both at position u = U[:,1] at time t. The parameter slot is not used and can be filled with nothing when calling.\n\nThe macro can be called without the code if the stream name has been defined beforehand via @define_stream.\n\nnote: Sign convention\nWe follow the \"oceanographic\" sign convention, whereby the velocity v is derived from the stream function psi by v = (-partial_ypsi partial_xpsi)\n\n\n\n\n\n","category":"macro"},{"location":"#StreamMacros.@velo_from_stream-Tuple{Symbol,Expr}","page":"Home","title":"StreamMacros.@velo_from_stream","text":"@velo_from_stream(name::Symbol, [code::Expr])\n\nGet the velocity field corresponding to a stream function on R^2. The defining code can be a series of definitions (in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe macro returns an anonymous function with signature (u,p,t) that returns an SVector{2} corresponding to the vector field at position u at time t. The parameter slot is not used and can be filled with nothing when calling.\n\nThe macro can be called without the code if the stream name has been defined beforehand via @define_stream.\n\nnote: Sign convention\nWe follow the \"oceanographic\" sign convention, whereby the velocity v is derived from the stream function psi by v = (-partial_ypsi partial_xpsi)\n\nExamples\n\njulia> using CoherentStructures\n\njulia> f = @velo_from_stream Ψ_ellipse begin\n               Ψ_ellipse = a*x^2 + b*y^2\n               a = t\n               b = 3\n           end\n(#3) #1 (generic function with 1 method)\n\njulia> f([1.0,1.0], nothing, 1.0)\n2-element StaticArrays.SArray{Tuple{2},Float64,1,2}:\n -6.0\n  2.0\n\njulia> using CoherentStructures\n\njulia> @define_stream Ψ_circular begin\n           Ψ_circular = f(x) + g(y)\n           # naming of function variables\n           # does not matter:\n           f(a) = a^2\n           g(y) = y^2\n       end\n\njulia> f2 = @velo_from_stream Ψ_circular\n(#5) #1 (generic function with 1 method)\n\njulia> f2([1.0,1.0], nothing, 0.0)\n2-element StaticArrays.SArray{Tuple{2},Float64,1,2}:\n -2.0\n  2.0\n\n\n\n\n\n","category":"macro"},{"location":"#StreamMacros.@vorticity_from_stream-Tuple{Symbol,Expr}","page":"Home","title":"StreamMacros.@vorticity_from_stream","text":"@vorticity_from_stream(name::Symbol, [code::Expr])\n\nGet the vorticity field as a function of (x, y, t) corresponding to a stream function on R^2.\n\nnote: Sign convention\nThe vorticity omega of the velocity field v = (v_x v_y) is defined as derived from the stream function psi by omega = partial_x v_x - partial_y v_y) = trace(nabla^2psi), i.e., the trace of the Hessian of the stream function.\n\n\n\n\n\n","category":"macro"},{"location":"#StreamMacros.call_subst-Tuple{Expr,Any,Any}","page":"Home","title":"StreamMacros.call_subst","text":"call_subst(expr::Expr, f_sig, f_body)\n\nSubstitute all function calls of f in expr.\n\n\n\n\n\n","category":"method"},{"location":"#StreamMacros.has_free_symb-Tuple{Expr,Any}","page":"Home","title":"StreamMacros.has_free_symb","text":"has_free_symb(ex::Expr, bound_vars)\n\nDoes ex contain a symbol that is not bound by bound_vars?\n\n\n\n\n\n","category":"method"},{"location":"#StreamMacros.remove_blocks-Tuple{Expr}","page":"Home","title":"StreamMacros.remove_blocks","text":"remove_blocks(ex::Expr)\n\nClean up enclosing blocks to get to the core expression.\n\n\n\n\n\n","category":"method"},{"location":"#StreamMacros.signature-Tuple{Symbol}","page":"Home","title":"StreamMacros.signature","text":"signature [<f_name> <arg1> <arg2> ...]\n\nA symbol is interpreted as a function without arguments.\n\n\n\n\n\n","category":"method"},{"location":"#StreamMacros.substitute_once-Tuple{Expr,Expr}","page":"Home","title":"StreamMacros.substitute_once","text":"substitute_once(defns::Expr, target::Expr)\n\nPerform all substitutions that are defined in code once.\n\n\n\n\n\n","category":"method"},{"location":"#StreamMacros.substitutions","page":"Home","title":"StreamMacros.substitutions","text":"substitutions(code::Expr, variable::Symbol, knowns = [])\n\nPerform all substitutions that are defined in code until the resulting expression does not contain free variables. Variables can be bound by knowns.\n\n\n\n\n\n","category":"function"},{"location":"#StreamMacros.sym_subst-Tuple{Symbol,Symbol,Any}","page":"Home","title":"StreamMacros.sym_subst","text":"sym_subst(expr, sym, s_expr)\n\nReplace all occurences of sym in expr by s_expr.\n\n\n\n\n\n","category":"method"}]
}
